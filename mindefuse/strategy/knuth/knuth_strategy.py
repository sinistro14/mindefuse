#!/usr/bin/env python3.7

from itertools import product, tee

from ..strategy import Strategy
from mindefuse.problem import Problem
from .score_count import SimpleScore, ParallelScore
from ..strategy_types import StrategyTypes


class KnuthStrategy(Strategy):
    """
    Knuth algorithm strategy.
    Given the number of possible elements of the secret, c, and the size of the secret sequence, s, the set of all
    possible codes contains c^s elements.
    1. Create a set S, the solution space, and a set A, all the unused codes, from the set of all possible codes.
    2. Generate an initial guess.
    3. Play the guess, g, and obtain the corresponding value of whites and reds.
    4. Verify if the game is over,
        if the maximum number of rounds has passed or
        if number of reds is equal to the size of the secret, if it is, the game is won.
    5. Remove g from S and from A.
    6. Otherwise, prune from S any code that would not give the same response if it was the secret sequence.
    7. Apply score_count to find the set of next possible guesses,
    For each code in A, calculate how many possibilities in S would be eliminated for each possible white+red peg score.
    The score of a code is the minimum number of possibilities it might eliminate from S.
    The best scores, are the lowest ones, since they assure that, in the worst case, the solution space gets as
    narrowed down as possible.
    Thus, the set of guesses is created with the minimum max scored sequences, B.
    8. Choose the next guess g, from B, by selecting, if possible, the lowest value also present in S, otherwise from A.
    9. Repeat from step 3.
    """

    """strategy identification type"""
    _type = StrategyTypes.KNUTH

    """score counter strategy"""
    __score_counter = SimpleScore

    @staticmethod
    def _initial_guess(problem):
        """
        Generates the first guess to use as input.
        Knuth's initial guess was '1122', which in our definition of 'numeric' would be '0011'.
        Considering a similar approach, our guess will be generated by using the first available element twice,
        and subsequent elements plus one, then crop the value to match the required size.
        :param problem: problem to which the guess will be submitted
        :return: sequence to use as the first guess
        """
        secret_size = problem.secret_size()
        possible_elements = problem.possible_elements()

        return "".join(time * el for time, el in zip(range(2, secret_size + 2), possible_elements))[:secret_size]

    @staticmethod
    def _generate_combinations(possible_elements, sequence_size):
        """
        Generates all possible combinations of elements with a given sequence size
        :param possible_elements: elements used to create the sequence
        :param sequence_size: size of the sequence to create
        :return: all possible combinations
        """
        return map(''.join, product(possible_elements, repeat=sequence_size))

    @staticmethod
    def _get_next_guess(guesses, all_combinations, solutions):
        """
        Chooses the next guess from the set of minimum max scored guesses
        :param guesses: guesses to choose from
        :param all_combinations: all available combinations
        :param solutions: current solution space
        :return: next guess
        """
        solutions = set(solutions)

        guesses1, guesses2 = tee(guesses)

        for guess in guesses1:
            if guess in solutions:
                return guess

        all_combinations = set((comb for comb in all_combinations if comb not in solutions))

        for guess in guesses2:
            if guess in all_combinations:
                return guess

    @staticmethod
    def _remove_guess(guesses, guess_to_remove):
        """
        Provide the list of guesses after removing another guess
        :param guesses: guesses
        :param guess_to_remove: guess to remove
        :return: guesses without the removed element
        """
        return (guess for guess in guesses if guess != guess_to_remove)

    @staticmethod
    def _prune_guesses(guesses, last_guess, answer):
        """
        Provides guesses after pruning all the sequences that would not provide the same response.
        :param guesses: guesses to be pruned
        :param last_guess: last sequence proposed as a solution
        :param answer: response to last_guess
        :return: pruned guesses
        """
        return (guess for guess in guesses if Problem.compare_sequences(guess, last_guess) == answer)

    def _mini_max(self, combinations, solutions):
        """
        Provide the list of minimum max scored sequences for the problem.
        :param combinations: all available combinations
        :param solutions: solution space
        :return: the minimum max scored guesses
        """
        scores = self.__score_counter.run(combinations, solutions)

        # minimum max score
        min_score = min(scores.values())

        # filter the sequences with the minimum max score
        return sorted((k for k, v in scores.items() if v == min_score))

    def solve_problem(self, problem):
        """
        Solves a problem using Knuth algorithm
        :param problem: problem to solve
        :return: problem after running the algorithm
        """
        secret_size = problem.secret_size()
        possible_elements = problem.possible_elements()

        # for a secret size inferior to 2, multiprocessing is slower
        if secret_size > 2:
            self.__score_counter = ParallelScore
        else:
            self.__score_counter = SimpleScore

        current_guess = self._initial_guess(problem)

        proposal = self.create_proposal(current_guess)

        answer = problem.check_proposal(proposal)

        solutions = self._generate_combinations(possible_elements, secret_size)
        all_combinations = self._generate_combinations(possible_elements, secret_size)

        while not problem.finished():

            # remove guess from pools
            solutions = self._remove_guess(solutions, current_guess)
            all_combinations = self._remove_guess(all_combinations, current_guess)

            # remove from solutions any code that would not give the same response if it was the secret sequence
            solutions = self._prune_guesses(solutions, current_guess, (answer.whites, answer.reds))

            solutions, solutions_aux = tee(solutions)
            all_combinations, all_combinations_aux = tee(all_combinations)
            next_guesses = self._mini_max(all_combinations_aux, solutions_aux)

            solutions, solutions_aux = tee(solutions)
            all_combinations, all_combinations_aux = tee(all_combinations)
            current_guess = self._get_next_guess(next_guesses, all_combinations_aux, solutions_aux)

            proposal = self.create_proposal(current_guess)

            answer = problem.check_proposal(proposal)

        return problem
