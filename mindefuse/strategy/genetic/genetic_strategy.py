#!/usr/bin/env python3.7

from deap import base, tools

from mindefuse.problem import Problem
from ..strategy import Strategy
from ..strategy_types import StrategyTypes
from .knuth_config import KnuthConfig as Config


class GeneticStrategy(Strategy):
    """
    Genetic strategy
    """

    _type = StrategyTypes.GENETIC

    @staticmethod
    def _initial_guess(problem):
        """
        Generates the first guess to use as input.
        Genetic's initial guess was '1122', which in our definition of 'numeric' would be '0011'.
        Considering a similar approach, our guess will be generated by using the first available element twice,
        and subsequent elements plus one, then crop the value to match the required size.
        :param problem: problem to which the guess will be submitted
        :return: sequence to use as the first guess
        """
        secret_size = problem.secret_size()
        possible_elements = problem.possible_elements()

        return "".join(time * el for time, el in zip(range(2, secret_size + 1), possible_elements))[:secret_size]

    @staticmethod
    def _generate_combinations(possible_elements, sequence_size):
        """
        Generates all possible combinations of elements with a given sequence size
        :param possible_elements: elements used to create the sequence
        :param sequence_size: size of the sequence to create
        :return: all possible combinations
        """
        return map(''.join, product(possible_elements, repeat=sequence_size))

    def _genetic_evolution(problem: Problem):
        population = [[random.randint(1, len(problem.possible_elements())) for i in range(problem.secret_size())] for j in range(Config.MAX_POP_SIZE)]

        best_matches = []
        h = 1
        k = 0

        toolbox = base.Toolbox()

        init = tools.initIterate(str, GeneticStrategy._generate_combinations())

        toolbox.register("attr_bool", problem.possible_elements())
        toolbox.register("individual", init, creator.Individual, toolbox.attr_bool, n=problem.secret_size())
        toolbox.register("population", tools.initRepeat, list, toolbox.individual)

        while len(best_matches) <= Config.MAX_POP_SIZE and h <= Config.MAX_GENERATIONS:

    def solve_problem(self, problem):
        """
        Solves a problem using Genetic algorithm
        :param problem: problem to solve
        :return: problem after running the algorithm
        """
        secret_size = problem.secret_size()
        possible_elements = problem.possible_elements()

        current_guess = self._initial_guess(problem)

        proposal = self.create_proposal(current_guess)

        answer = problem.check_proposal(proposal)

        while not problem.finished():




        

