#!/usr/bin/env python3.7

import random as rnd

from mindefuse.problem import Problem
from ..strategy import Strategy
from ..strategy_types import StrategyTypes
from .genetic_config import GeneticConfig as Config


class GeneticStrategy(Strategy):
    """
    Genetic algorithm strategy
    Given the number of possible elements of the secret C, and the size of the secret sequence, S,
    1. Play fixed initial guess and record its response.
    2. While game is not finished:
    3.      Initialize random population.
    4.      Run genetic algorithm on population to generate children.
    5.      Compute fitness score for each child.
    6.      Return eligible children.
    7. Play one of the eligible guesses.
    8. Repeat from step 2.
    """

    _type = StrategyTypes.GENETIC

    @staticmethod
    def _initial_guess(problem):
        """
        Generates the first guess to use as input.
        Genetic's initial guess was '1122', which in our definition of 'numeric' would be '0011'.
        Considering a similar approach, our guess will be generated by using the first available element twice,
        and subsequent elements plus one, then crop the value to match the required size.
        :param problem: problem to which the guess will be submitted
        :return: sequence to use as the first guess
        """
        secret_size = problem.secret_size()
        possible_elements = problem.possible_elements()

        return "".join(time * el for time, el in zip(range(2, secret_size + 1), possible_elements))[:secret_size]

    @staticmethod
    def _get_indexes(size):
        """
        Generates two random distinct indexes of a guess.
        :param size: The size (length) of guess.
        :return: A tuple with both indexes, in ascending order.
        """
        idxs = rnd.sample(range(0, size-1), 2)
        return min(idxs), max(idxs)

    @staticmethod
    def _one_point(first_code, second_code):
        """
        Executes one-point crossover on the input codes.
        :param first_code: The first code participating in the crossover.
        :param second_code: The second code participating in the crossover.
        :returns: A tuple of two codes.
        """
        idx = rnd.randint(0, len(first_code)-1)
        first_code[idx:], second_code[idx:] = second_code[idx:], first_code[idx:]
        return first_code, second_code

    @staticmethod
    def _two_point(first_code, second_code):
        """
        Executes a two-point crossover on the input codes.
        :param first_code: The first code participating in the crossover.
        :param second_code: The second code participating in the crossover.
        :returns: A tuple of two codes.
        """
        idx1, idx2 = GeneticStrategy._get_indexes(len(first_code))
        first_code[idx1:idx2], second_code[idx1:idx2] = second_code[idx1:idx2], first_code[idx1:idx2]
        return first_code, second_code

    @staticmethod
    def _crossover(first_code, second_code):
        """
        Executes either a one-point or two-point crossover on the input codes, based
        on a certain probability (default: CROSSOVER_PROB = 0.5).
        :param first_code: The first code participating in the crossover.
        :param second_code: The second code participating in the crossover.
        :returns: A tuple of two codes.
        """
        return GeneticStrategy._one_point(first_code, second_code) if rnd.random() > Config.CROSSOVER_PROB \
            else GeneticStrategy._two_point(first_code, second_code)

    @staticmethod
    def _mutation(code, elements):
        """
        Executes a mutation that replaces the element of one randomly chosen position by
        a random other element (from all possible elements).
        :param code: The code to mutate.
        :param elements: List of all possible elements.
        :return: Mutated code.
        """
        code[rnd.randint(0, len(code) - 1)] = elements[rnd.randint(0, len(elements) - 1)]
        return code

    @staticmethod
    def _permutation(code):
        """
        Executes a permutation that swaps two random elements of the code.
        :param code: The code to permute.
        :return: Permuted code.
        """
        idx1, idx2 = GeneticStrategy._get_indexes(len(code))
        code[idx1], code[idx2] = code[idx2], code[idx1]
        return code

    @staticmethod
    def _inversion(code):
        """
        Executes an inversion, where two positions are randomly picked,
        and the sequence of elements between these positions is inverted.
        :param code: The code on which the inversion will be made.
        :return: Inverted code.
        """
        idx1, idx2 = GeneticStrategy._get_indexes(len(code))
        code[idx1:idx2] = code[idx1:idx2][::-1]
        return code

    @staticmethod
    def _random_guess(elements, problem):
        """
        Generates a random guess.
        :param elements: List of all possible elements.
        :param problem: Problem from which the guess will be generated
        :return: Generated guess.
        """
        return [elements[rnd.randint(0, len(elements) - 1)] for _ in range(problem.secret_size())]

    @staticmethod
    def _fitness_score(trial, guesses, problem):
        """
        Computes fitness score associated with a potential sequence/code. This fitness score is calculated based on
        previous guesses. We compare the sequence with each guess, retrieving the difference between whites and reds
        from them. Said differences are then used to calculate the score using the formula:
        sum_dif(reds) + sum_dif(whites)
        :param trial: Sequence to test.
        :param guesses: List of previous guesses.
        :param problem: Problem used to compare sequences.
        :return: Fitness score.
        """
        sum_whites = sum_reds = 0
        for i in range(1, len(guesses) + 1):
            guess = guesses[i-1]
            guess_whites, guess_reds = guess.whites, guess.reds

            play_whites, play_reds = problem.compare_sequences(guess.sequence, "".join(trial))

            sum_reds += abs(play_reds - guess_reds)
            sum_whites += abs(play_whites - guess_whites)

        return sum_reds + sum_whites

    def _genetic_evolution(self, max_population, max_generations, problem: Problem, guesses):
        """
        Performs the genetic evolution of a population (randomly generated), which is a process inspired by natural
        selection, by the usage bio-inspired operators. In this implementation, these operators consist of Crossover
        (both one-point and two-point variations with 0.5 probability each), Mutation and Permutation (probability of
        0.03) and Inversion(probability of 0.02). An eligibility list of potential guesses is populated with the fitness
        score of each guess. In case a generated child is already present in the population, we randomly generate a
        guess in order to diversify our pool of guesses.
        :param max_population: The maximum size of initial population and eligibility list.
        :param max_generations: The maximum number of times the population suffers the genetic evolution.
        :param problem: Problem used generate the population from.
        :param guesses: List of previous guesses.
        :return: List of eligible (fitness_score = 0) guesses.
        """
        elements = problem.possible_elements()

        population = [self._random_guess(elements, problem) for _ in range(max_population)]

        eligible = []
        h = 1

        while len(eligible) <= max_population and h <= max_generations:

            """Genetic Evolution"""
            offspring = []

            for i in range(len(population) - 1):

                children = self._crossover(population[i], population[i+1])

                for child in children:
                    if rnd.random() <= Config.MUTATION_PROB:
                        child = self._mutation(child, elements)

                    if rnd.random() <= Config.PERMUTATION_PROB:
                        child = self._permutation(child)

                    if rnd.random() <= Config.INVERSION_PROB:
                        child = self._inversion(child)

                    if child in population:
                        child = self._random_guess(elements, problem)

                    offspring.append(child)

            """Eligibility Test"""
            for child in offspring:
                if self._fitness_score(child, guesses, problem) == 0 and "".join(child) not in eligible:
                    eligible.append("".join(child))
            h += 1

        return eligible

    def solve_problem(self, problem):
        """
        Solves a problem using Genetic algorithm
        :param problem: problem to solve
        :return: problem after running the algorithm
        """
        current_guess = self._initial_guess(problem)

        proposal = self.create_proposal(current_guess)

        problem.check_proposal(proposal)

        guesses = [proposal]

        while not problem.finished():

            eligibles = self._genetic_evolution(Config.MAX_POPULATION, Config.MAX_GENERATIONS, problem, guesses)

            """Scales genetic evolution for higher complexities"""
            scale = 2
            while not eligibles:
                eligibles = self._genetic_evolution(Config.MAX_POPULATION * scale, Config.MAX_GENERATIONS * scale,
                                                    problem, guesses)
                scale += 1

            """Randomly select an eligible guess"""
            guess = eligibles[rnd.randint(0, len(eligibles) - 1)]

            proposal = self.create_proposal(guess)

            guesses.append(proposal)

            problem.check_proposal(proposal)

        return problem
