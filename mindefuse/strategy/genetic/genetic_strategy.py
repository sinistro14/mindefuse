#!/usr/bin/env python3.7

import random as rnd

from mindefuse.problem import Problem
from ..strategy import Strategy
from ..strategy_types import StrategyTypes
from .genetic_config import GeneticConfig as Config


class GeneticStrategy(Strategy):
    """
    Genetic strategy
    """

    _type = StrategyTypes.GENETIC

    @staticmethod
    def _initial_guess(problem):
        """
        Generates the first guess to use as input.
        Genetic's initial guess was '1122', which in our definition of 'numeric' would be '0011'.
        Considering a similar approach, our guess will be generated by using the first available element twice,
        and subsequent elements plus one, then crop the value to match the required size.
        :param problem: problem to which the guess will be submitted
        :return: sequence to use as the first guess
        """
        secret_size = problem.secret_size()
        possible_elements = problem.possible_elements()

        return "".join(time * el for time, el in zip(range(2, secret_size + 1), possible_elements))[:secret_size]

    @staticmethod
    def _get_indexes(size):
        """
        Generates two random distinct indexes of a guess.
        :param size: The size (length) of guess.
        :return: A tuple with both indexes, in ascending order.
        """
        idxs = rnd.sample(range(0, size-1), 2)
        return min(idxs), max(idxs)

    @staticmethod
    def _one_point(first_code, second_code):
        """
        Executes one-point crossover on the input codes.
        :param first_code: The first code participating in the crossover.
        :param second_code: The second code participating in the crossover.
        :returns: A tuple of two codes.
        """
        idx = rnd.randint(0, len(first_code)-1)
        first_code[idx:], second_code[idx:] = second_code[idx:], first_code[idx:]
        return first_code, second_code

    @staticmethod
    def _two_point(first_code, second_code):
        """
        Executes a two-point crossover on the input codes.
        :param first_code: The first code participating in the crossover.
        :param second_code: The second code participating in the crossover.
        :returns: A tuple of two codes.
        """
        idx1, idx2 = GeneticStrategy._get_indexes(len(first_code))
        first_code[idx1:idx2], second_code[idx1:idx2] = second_code[idx1:idx2], first_code[idx1:idx2]
        return first_code, second_code

    @staticmethod
    def _crossover(first_code, second_code):
        """
        Executes either a one-point or two-point crossover on the input codes, based
        on a certain probability (default: CROSSOVER_PROB = 0.5).
        :param first_code: The first code participating in the crossover.
        :param second_code: The second code participating in the crossover.
        :returns: A tuple of two codes.
        """
        return GeneticStrategy._one_point(first_code, second_code) if rnd.random() > Config.CROSSOVER_PROB else GeneticStrategy._two_point(first_code, second_code)

    @staticmethod
    def _mutation(code, elements):
        """
        Executes a mutation that replaces the element of one randomly chosen position by
        a random other element (from all possible elements).
        :param code: The code to mutate.
        :param elements: List of all possible elements.
        :return: Mutated code.
        """
        code[rnd.randint(0, len(code)-1)] = elements[rnd.randint(0, len(elements)-1)]
        return code

    @staticmethod
    def _permutation(code):
        """
        Executes a permutation that swaps two random elements of the code.
        :param code: The code to permute.
        :return: Permuted code.
        """
        idx1, idx2 = GeneticStrategy._get_indexes(len(code))
        code[idx1], code[idx2] = code[idx2], code[idx1]
        return code

    @staticmethod
    def _inversion(code):
        """
        Executes an inversion, where two positions are randomly picked,
        and the sequence of elements between these positions is inverted.
        :param code: The code on which the inversion will be made.
        :return: Inverted code.
        """
        idx1, idx2 = GeneticStrategy._get_indexes(len(code))
        code[idx1:idx2] = code[idx1:idx2][::-1]
        return code

    @staticmethod
    def _random_guess(elements, problem):
        """
        Generates a random guess.
        :param elements: List of all possible elements.
        :param problem: Problem from which the guess will be generated
        :return: Generated guess.
        """
        return [elements[rnd.randint(0, len(elements)-1)] for _ in range(problem.secret_size())]

    @staticmethod
    def _fitness_score(trial, guesses, problem):
        """
        Computes fitness score associated with a potential sequence/code. This fitness score is calculated based on
        previous guesses. We compare the sequence with each guess, retrieving the difference between whites and reds
        from them. Said differences are then used to calculate the score using the formula:
        2 x sum_dif(whites) + sum_dif(reds)
        Where an additional constant, 2 x P x (i - 1), is added at each red difference in order to slick the values
        of the fitness function.
        :param trial: Sequence to test.
        :param guesses: List of previous guesses.
        :param problem: Problem used to compare sequences.
        :return: Fitness score.
        """
        sum_whites, sum_reds = 0, 0
        pos = problem.secret_size()
        for i in range(1, len(guesses)+1):
            guess = guesses[i-1]
            guess_whites, guess_reds = guess.whites, guess.reds

            play_whites, play_reds = problem.compare_sequences(guess.sequence, "".join(trial))

            sum_whites += abs(play_whites - guess_whites)
            sum_reds += abs(play_reds - guess_reds) + 2 * pos * (i - 1)

        return 2 * sum_whites + sum_reds

    def _genetic_evolution(self, problem: Problem, elements, guesses):
        population = [self._random_guess(elements, problem) for _ in range(Config.MAX_POPULATION)]

        eligible = []
        h = 1

        while len(eligible) <= Config.MAX_POPULATION and h <= Config.MAX_GENERATIONS:

            offspring = list()

            for i in range(len(population)-1):

                children = self._crossover(population[i], population[i+1])

                for child in children:
                    if rnd.random() <= Config.MUTATION_PROB:
                        child = self._mutation(child, elements)

                    if rnd.random() <= Config.PERMUTATION_PROB:
                        child = self._permutation(child)

                    if rnd.random() <= Config.INVERSION_PROB:
                        child = self._inversion(child)

                    if child in population:
                        child = self._random_guess(elements, problem)

                    offspring.append(child)

            for child in offspring:
                if self._fitness_score(child, guesses, problem) == 0 and "".join(child) not in eligible:
                    eligible.append("".join(child))
            h += 1

    def solve_problem(self, problem):
        """
        Solves a problem using Genetic algorithm
        :param problem: problem to solve
        :return: problem after running the algorithm
        """
        secret_size = problem.secret_size()
        possible_elements = problem.possible_elements()

        current_guess = self._initial_guess(problem)

        proposal = self.create_proposal(current_guess)

        answer = problem.check_proposal(proposal)

        guesses = [proposal]

        self._genetic_evolution(problem, possible_elements, guesses)

        #while not problem.finished():
            #self._genetic_evolution(problem, possible_elements)




        

