#!/usr/bin/env python3.7

import random as rnd

from mindefuse.problem import Problem
from ..strategy import Strategy
from ..strategy_types import StrategyTypes
from .genetic_config import GeneticConfig as Config


class GeneticStrategy(Strategy):
    """
    Genetic strategy
    """

    _type = StrategyTypes.GENETIC

    @staticmethod
    def _initial_guess(problem):
        """
        Generates the first guess to use as input.
        Genetic's initial guess was '1122', which in our definition of 'numeric' would be '0011'.
        Considering a similar approach, our guess will be generated by using the first available element twice,
        and subsequent elements plus one, then crop the value to match the required size.
        :param problem: problem to which the guess will be submitted
        :return: sequence to use as the first guess
        """
        secret_size = problem.secret_size()
        possible_elements = problem.possible_elements()

        return "".join(time * el for time, el in zip(range(2, secret_size + 1), possible_elements))[:secret_size]

    @staticmethod
    def _get_indexes(size):
        """
        Generates two random distinct indexes of a guess.
        :param size: The size (length) of guess.
        :return: A tuple with both indexes, in ascending order.
        """
        idxs = rnd.sample(range(0, size), 2)
        return min(idxs), max(idxs)

    @staticmethod
    def _one_point(first_code, second_code):
        """
        Executes one-point crossover on the input codes.
        :param first_code: The first code participating in the crossover.
        :param second_code: The second code participating in the crossover.
        :returns: A tuple of two codes.
        """
        idx = rnd.randint(0, len(first_code))
        first_code[idx:], second_code[idx:] = second_code[idx:], first_code[idx:]
        return first_code, second_code

    @staticmethod
    def _two_point(first_code, second_code):
        """
        Executes a two-point crossover on the input codes.
        :param first_code: The first code participating in the crossover.
        :param second_code: The second code participating in the crossover.
        :returns: A tuple of two codes.
        """
        idx1, idx2 = GeneticStrategy._get_indexes(len(first_code))
        first_code[idx1:idx2], second_code[idx1:idx2] = second_code[idx1:idx2], first_code[idx1:idx2]
        return first_code, second_code

    @staticmethod
    def _crossover(first_code, second_code):
        """
        Executes either a one-point or two-point crossover on the input codes, based
        on a certain probability (default: CROSSOVER_PROB = 0.5).
        :param first_code: The first code participating in the crossover.
        :param second_code: The second code participating in the crossover.
        :returns: A tuple of two codes.
        """
        return GeneticStrategy._one_point(first_code, second_code) if rnd.random() > Config.CROSSOVER_PROB else GeneticStrategy._two_point(first_code, second_code)

    @staticmethod
    def _mutation(code, elements):
        """
        Executes a mutation that replaces the element of one randomly chosen position by
        a random other element (from all possible elements).
        :param code: The code to mutate.
        :param elements: List of all possible elements.
        :return: Mutated code.
        """
        code[rnd.randint(0, len(code))] = elements[rnd.randint(0, len(elements))]
        return code

    @staticmethod
    def _permutation(code):
        """
        Executes a permutation that swaps two random elements of the code.
        :param code: The code to permute.
        :return: Permuted code.
        """
        idx1, idx2 = GeneticStrategy._get_indexes(len(code))
        code[idx1], code[idx2] = code[idx2], code[idx1]
        return code

    @staticmethod
    def _inversion(code):
        """
        Executes an inversion, where two positions are randomly picked,
        and the sequence of elements between these positions is inverted.
        :param code: The code on which the inversion will be made.
        :return: Inverted code.
        """
        idx1, idx2 = GeneticStrategy._get_indexes(len(code))
        code[idx1:idx2] = code[idx1:idx2][::-1]
        return code

    @staticmethod
    def _random_guess(elements, problem):
        """
        Generates a random guess.
        :param elements: List of all possible elements.
        :param problem: Problem from which the guess will be generated
        :return: Generated guess.
        """
        return [elements[rnd.randint(0, len(elements)-1)] for _ in range(problem.secret_size())]

    def _genetic_evolution(self, problem: Problem, elements):
        population = [self._random_guess(elements, problem) for _ in range(Config.MAX_POPULATION)]

        best_matches = []
        h = 1
        k = 0

        #print(population[0])
        """Remember to copy code, otherwise it changes in place!"""
        #print(self._random_guess(elements, problem))

        #while len(best_matches) <= Config.MAX_POP_SIZE and h <= Config.MAX_GENERATIONS:

    def solve_problem(self, problem):
        """
        Solves a problem using Genetic algorithm
        :param problem: problem to solve
        :return: problem after running the algorithm
        """
        secret_size = problem.secret_size()
        possible_elements = problem.possible_elements()

        current_guess = self._initial_guess(problem)

        proposal = self.create_proposal(current_guess)

        answer = problem.check_proposal(proposal)

        self._genetic_evolution(problem, possible_elements)

        #while not problem.finished():
            #pass




        

